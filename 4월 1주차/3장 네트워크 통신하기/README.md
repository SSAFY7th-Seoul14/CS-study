### 데이터 전송시 사용하는 통신 방식의 종류에 대해 설명해주세요  
유니 캐스트 - 1대1. 대부분의 통신  
브로드 캐스트 - 1대 모든(동일 네트워크 모든 호스트) 통신  
멀티 캐스트 - 1대 그룹(구독 호스트) 통신. 다수의 특정 목적지  
애니 캐스트 - 1대1. 가장 가까운 호스트에서 응답. -> 가까운 DNS 서버 찾을 때 사용  

### MAC 주소, IP 주소를 비교해서 설명해주세요.
MAC과 IP 둘다 장치가 네트워크의 다른 장치와 통신하기 위해 이용되는 주소들.  
MAC은 `2계층 NIC 하드 웨어 자체에 부여된 고유 식별 번호`로 시리얼 넘버와 비슷한 물리적 주소. 특수한 방법이 아니고선 변경이 불가  
48비트 16진수 12자리 ":"로 구분 / 앞 6자리 제조사에 할당된 OUI / 뒷 6자리 제조사에서 할당한 UAA / 나누는 기준이 고정되어 있다.  
IP는 3계층. 논리적 주소로 사용자가 변경 가능하다.  
10진수 표기 8bit의 옥텟이 한 단위. version에 따라 크기가 다르나 공용화 되어있는 IPv4의 경우 32 bit, v6의 경우 128bit  
주소에 레벨이 있어서 네트워크 주소와 호스트 주소로 나뉜다. MAC과 달리 호스트, 네트워크 나누는 기준이 고정되어 있지 않다.

### Classless IP 주소 체계의 탄생 배경(Classful의 한계)과 서브넷 마스크를 이용해 호스트, 네트워크를 구분하는 방법에 대해 설명해주세요.
Classful 체계에서 주소 자체의 부족 + 할당 받고 사용하지 않아 낭비(한 조직에 할당되기만 해도 다른 기관에서 사용할 수가 없었다.) 이렇게 낭비되는 IP 주소만 해도 수천만 개.  
2진수의 and 연산을 활용. `반드시` 서브넷 마스크가 필요하다.
왜낭비되는지 이해가 안된다면 전화번호를 생각
지역번호(클래스) 정해져있어서 02로 시작하면 서울인걸 알수있다. 근데 02-0000-0000 뒤에 8자리가 전부 쓰이진 않는다 (낭비)
핸드폰번호(클래스리스) , 번호만 보고 어떤지역인지는 알 수 없지만, 낭비적다.

### 네트워크 사용자 입장에서의 간단한 서브네팅 방법, 과정에 대해 설명
간단한 서브네팅  
	1. 서브넷 마스크를 2진수 변환  
	2. 서브넷 최대 IP 개수 크기 파악(호스트용)  
	3. 서브넷 최대 크기로 나열  
	4. 호스트가 속한 네트워크 선택  
	5. 필요한 주소(네트워크, 브로드 캐스트, 유효 IP 범위) 체크  
![image](https://user-images.githubusercontent.com/72867880/161293680-20a44dce-cc08-4113-bb73-e26b08a70a41.png)


### ARP 동작에서 사용되는 필드?
송신자 MAC, IP, 대상자 MAC, IP

### TCP와 UDP의 특징과 차이점
TCP는 양방향이고 UDP는 단방향  
TCP는 신뢰성 있는 데이터 전송, UDP는 데이터 전송 보장 X  
TCP는 연결지향형 프로토콜이고 UDP는 비연결지향형 프로토콜  
TCP는 혼잡제어 및 흐름제어 지원, UDP는 지원 X  
TCP는 느림 / UDP는 빠름
TCP는 1:1통신 / UDP는 1:1 , 1:N, N:N 모두가능
TCP는 전송순서보장(Seq no) / UDP는 보장 x

### TCP 3-way handshake 설명과 동작 방법
3-way handshake는 통신을 하는 장치 간에 서로 연결이 잘 되어 있는지 확인하는 과정이다.  
양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전 수신측이 준비가 되었다는 것을 알 수 있도록 한다.

1) 클라이언트는 서버에 접속을 요청하는 SYN(a) 패킷 전송  
2) 서버는 클라이언트의 요청인 SYN(a) 패킷에 대한 수락 응답으로 ACK(a+1) 패킷과 클라이언트도 포트 열어달라는 SYN(b) 패킷 전송  
3) 클라이언트가 ACK(a+1), SYN(b) 잘 받았으면 응답으로 ACK(b+1) 패킷 보내면서 연결이 성립됨  

### TCP 4-way handshake 설명 
4-way handshake는 연결(세션)을 종료하기 위한 작업
이를 하지 않으면, 한쪽에서는 연결이 종료됐는지 알지못해 무한대기 상태에 빠져 데드락 발생가능성 존재하므로, 매우 중요한 작업

1) 클라이언트가 연결 종료하겠다는 FIN 플래그 전송. 클라이언트는 FIN-WAIT 상태
2) 서버가 FIN 플래그 받으면, 일단 확인했다는 ACK 전송 후 자신의 통신이 끝날 때까지 대기. 서버는 CLOSE_WAIT 상태
3) 서버가 연결 종료 준비가 되면, 연결해지 준비가 되었다는 걸 알리기 위해 클라이언트에게 FIN 플래그 전송. 서버의 상태는 LAST_WAIT
4) 클라이언트는 해지준비가 되었다는 ACK를 확인했다는 메시지 보냄. 클라이언트 상태가 FIN-WAIT에서 TIME-WAIT으로 변경됨

### TCP의 신뢰성 보장 방법 - 흐름제어 (Stop and wait, Sliding Window)
**송신(호스트) <-> 수신(호스트) **   
`송신측과 수신측 사이의 데이터 처리 속도 차이(흐름)`를 제어하기 위한 기법으로 흐름제어를 하여 수신자의 버퍼 오버플로우를 방지
>1. Stop and Wait   

매번 전송한 패킷에 대해 확인 응답(ACK)을 받으면 다음 패킷 전송하는 방법. 비효율적임
![https://velog.velcdn.com/images/bobae1998/post/f091f43a-421e-4c72-a7ec-dc637d3788ca/image.png](https://velog.velcdn.com/images/bobae1998/post/f091f43a-421e-4c72-a7ec-dc637d3788ca/image.png)
>2. Sliding Window   

수신측에서 설정한 윈도우 사이즈만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 `데이터 흐름을 동적으로 조절`하는 제어 기법. Stop and Wait의 비효율성을 개선한 기법. 윈도우에 포함된 패킷을 계속 전송하고, 수신 측으로부터 ACK을 받으면 윈도우를 옆으로 옮겨 다음 패킷들을 전송
![https://velog.velcdn.com/images/bobae1998/post/42a45dd7-3333-41c6-b142-34ace6e9dada/image.png](https://velog.velcdn.com/images/bobae1998/post/42a45dd7-3333-41c6-b142-34ace6e9dada/image.png)

### TCP의 신뢰성 보장 방법 - 혼잡제어 (AIMD, Slow start, fast retransmit, fast recovery)
**송신(호스트) <-> 라우터(네트워크) **  
혼잡제어는 `송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이`를 해결하기 위한 기법. 네트워크 혼잡을 피하기 위해 송신측에서 데이터의 전송 속도를 강제로 줄이게 됨.

>1. AIMD(Additive Increase Multivative Decrease)   

패킷을 하나씩 보내고, 문제 없이 도착하면 윈도우 크기를 1씩 증가시키며 전송. 만약 실패하면 윈도우 크기 `절반`으로 줄인다. 제대로 된 속도로 통신하기 까지 시간이 오래 걸리고, 네트워크가 혼잡해지고 나서야 대역폭을 줄인다는 단점.
![https://velog.velcdn.com/images/bobae1998/post/07f0cf29-8a5f-48f8-bf48-2c0c708c0104/image.png](https://velog.velcdn.com/images/bobae1998/post/07f0cf29-8a5f-48f8-bf48-2c0c708c0104/image.png)
> 2. Slow start(느린 시작)

윈도우의 크기를 1, 2, 4, 8...과 같이 지수적으로 증가시키다 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식. 보낸 데이터의 ACK가 도착할 때마다 윈도우 크기를 지수적으로 증가시키기 때문에 초반엔 느리게 증가할지라도 시간이 지날수록 윈도우 크기가 빨리 증가한다는 장점이 있다.
![https://velog.velcdn.com/images/bobae1998/post/834ab99a-b1d0-46cc-b459-23eab50844ac/image.png](https://velog.velcdn.com/images/bobae1998/post/834ab99a-b1d0-46cc-b459-23eab50844ac/image.png)
> 3. fast retransmit(빠른 재전송)

TCP의 혼잡 조절에 추가된 정책으로 수신측에서 먼저 도착해야할 패킷이 아닌 그 다음 패킷이 도착한 경우에도 ACK 패킷을 송신측으로 보낸다. 


예를 들어 1, 2, 3, 4,.. 번의 데이터가 순서대로 와야 하는데 실제론 2, 3 다음에 5번이 왔다. 이런 상황에서 수신측은 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보낸다. 그리고 이런 중복 ACK를 3개 받으면 재전송이 이루어진다.

송신측은 자신이 설정한 타임아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기에 빠른 전송률을 유지할 수 있다.

송신측에서 설정한 타임아웃까지 ACK를 받지 못하면 혼잡이 발생한 것으로 판단하여 혼잡 회피를 한다.
> 4. fast recovery(빠른 회복)

혼잡 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법. 이 방법을 적용하면 혼잡 상황을 한 번 겪고 나서부터는 AIMD 방식으로 동작함.


### TCP의 신뢰성 보장 방법 - 오류제어 (Stop and Wait ARQ, GBn ARQ, SR ARQ)
오류 검출과 재전송을 포함한다.   
ARQ : 신뢰성 있는 데이터 전달을 위해 재전송을 기반으로 한 에러 제어 방식
> 1. Stop and Wait ARQ

전송측은 수신측에서 보내준 ACK를 받기 전까지 프레임의 복사본을 유지함. 식별을 위해 데이터와 ACK는 각각 0, 1 번호를 부여한다. 수신측이 데이터를 받지 못했을 경우, 송신측에게 NAK를 보내고 NAK를 받은 송신측은 데이터를 재전송한다.

>2. Go Back N ARQ (GBn ARQ)

전송된 프레임이 손상, 분실된 경우 그리고 ACK 프레임의 손실로 인해 타임아웃이 발생한 경우, `확인된 마지막 프레임 이후로 모든 프레임을 재전송`한다.
![https://velog.velcdn.com/images/bobae1998/post/12cda25f-66fb-42b0-8722-d732d29b8f2f/image.png](https://velog.velcdn.com/images/bobae1998/post/12cda25f-66fb-42b0-8722-d732d29b8f2f/image.png)
> 3. Selective Reject (SR) ARQ

GBn의 확인된 마지막 프레임 이후 모든 프레임을 재전송하는 것의 단점을 보완한 기법으로 SR은 손상되거나 손실된 프레임만 재전송한다. 그렇기에 별도의 데이터 재정렬이 필요하며, 버퍼도 필요로 하고 SR에 비해 비용이 든다.

참고: [흐름제어 & 혼잡제어 & 오류제어](https://github.com/GimunLee/tech-refrigerator/blob/master/Network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20%26%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4%20%26%20%EC%98%A4%EB%A5%98%EC%A0%9C%EC%96%B4.md)   
[TCP 혼잡 제어](https://velog.io/@mu1616/TCPIP-%ED%98%BC%EC%9E%A1-%EC%A0%9C%EC%96%B4)
### 슬라이딩 윈도우란?
한 번에 데이터를 받을 수 있는 데이터 크기인 윈도 사이즈를 네트워크 상황에 따라 조절하는 것

### 서브네팅이란?
클래스의 기준을 무시하고 새로운 네트워크-호스트 구분 기준을 사용자가 정해 클래스풀 단위의 네트워크보다 더 쪼개 사용하는 것  
IP 주소 낭비를 방지하기 위해 서브넷 마스크를 이용하여 네트워크 영역과 호스트 영역으로 쪼개는 과정

### Bogon Ip란?
여러 이유로 공인 Ip로 할당하지 않는 IP주소/대역폭. 로컬 호스트나 사설 네트워크 등이 존재한다.

### 클래스 풀과 클래스리스 네트워크의 차이점
클래스 풀은 현재는 사용되지 않는 방식이며, 네트워크 주소와 호스트 주소를 나누는 구분자 위치를 맨 앞 옥텟의 주소에 따라 정한다.

반면 클래스리스 네트워크는 서브넷 마스크를 사용해 네트워크와 호스트를 구분한다. 주로 255.255.255.0과 같은 형태로 사용되며,
2진법으로 1인 자리가 모두 네트워크 주소가 된다. 다른 방식으로는 /8, /16, /24 등의 표기로 A, B, C 클래스를 표기한다.
옥텟단위가 아닌 더 작은 단위로도 분할 가능(서브네팅)하다.

### TCP 슬라이딩 윈도우에 대해 설명해주세요
효율적인 전송을 위해 한 번에 일정량의 패킷을 전송하고 응답 패킷을 받는다.
이 때 데이터의 크기를 윈도우 사이즈라고 하며, 기본은 최대 2^16이다. 마지막 비트를 시프팅해서 더 늘리는 방법도 있다.
슬라이딩 윈도우는 윈도 사이즈를 네트워크 상황에 따라 동적으로 조절하는 개념이다.
데이터 유실이 발생하면 윈도 사이즈를 절반으로 떨어뜨리고 서서히 증가시킨다.

### BUM 트래픽이란?
브로드캐스트, 언노운 유니캐스트, 멀티캐스트 트래픽을 총칭하는 말.
이 셋은 서로 다른 종류의 트래픽이지만 네트워크에서 비슷하게 동작해 한 묶음으로 칭하게 되었다.
동일 네트워크의 모든 주소로 송신하기 때문에, 불필요한 BUM 트래픽이 많아지면 네트워크 성능이 저하된다.
   
### ARP 동작방식에 대해 간략히 설명해주세요.(송신(전송자) MAC/IP, 수신(대상자) MAC/IP)
1) ARP요청을 브로드캐스팅 주소로 보내 브로드캐스팅합니다. 이 때 전송자 정보는 자기 정보, 목적지 MAC은 브로드캐스트 주소, 대상자 MAC은 전부 0으로 채우고 대상자 IP는 알고 있으므로 제대로 채워줍니다.
2) 브로드캐스팅 주소를 통해 모든 장비에 전달된 패킷 중 대상자 IP주소를 가진 단말이 ARP요청을 처리하고 응답합니다. 이때 응답하는 쪽은 모든 정보를 알고 있으므로 완전한 패킷을 보냅니다. 이 응답은 유니캐스트입니다.
3) 이제 이 응답을 가지고 ARP캐시 테이블을 갱신합니다.

### GARP(Gratuitous ARP)의 용도 세가지 간략 설명
1) IP주소 충돌 감지 - 오지 않아야 할 응답이 오는 경우
2) 상대방의 ARP테이블 갱신(동일 서브넷) - 가상MAC주소를 사용하지 않는 데이터베이스 HA(고가용성 솔루션: 다수의 시스템을 1개의 클러스터로 사용해 한 서버에서 문제가 발생해도 즉각 다른 서버가 업무를 수행한다.)에서 주로 사용합니다. 기존 서버와 통신하던 단말은 기존의 MAC주소가 남아 새로운 서버와 연결되지 못 하는데, 스탠바이 장비가 활성화될 때 GARP 패킷을 보내면 ARP테이블을 갱신한다.
다만 보안상의 이유로 막힌 장비가 많아 최근은 잘 사용되지 않으며, 주로 가상MAC을 사용한다.
3) HA 용도의 클러스터링, VRRP, HSRP - 마찬가지로 장비 이중화를 위해 사용되지만, 가상 MAC을 사용하는 경우이다.  - 슬레이브/마스터 변경시 포트번호를 바꾸기 위해 사용된다.

### L2 통신과 L3 통신의 차이점에 대해 간략히 설명해 주세요.
1) 정확한 명칭은 로컬 네트워크 통신, 원격지 네트워크 통신이며, 통신 시 로컬 네트워크에서는 2계층(ARP)까지만 정보를 확인해서 통신하고, L3의 경우 라우터와 같은 3계층 장비가 없으면 통신할 수 없다.
2) L2는 그냥 ARP 요청을 보내면 되지만, L3는 ARP요청을 기본 게이트웨이의 IP주소로 요청합니다. 이때 받는 응답의 IP주소는 목적지 Ip이지만, MAC주소는 기본 게이트웨이의 주소가 사용된다.

### ARP란 무엇인지 왜 필요한지 등을 설명해주세요

2계층 MAC과 3계층 IP는 서로 연관이 없기 때문에 둘을 묶어주는 과정이 필요한데 그것이 바로 ARP(Address Resolution Protocol)

통신 시도에서 출발지, 목적지 IP를 알고 자신의 MAC 주소는 알지만 상대의 MAC 주소를 알 수 없을 때 2계층에서 인캡슐을 진행할 수 없다. 그래서 ARP 브로드캐스트를 통해 목적지 MAC을 알아내고 인캡슐을 통해 정상적으로 전달할 수 있다.